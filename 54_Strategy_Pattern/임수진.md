# 전략 패턴 (Strategy Pattern)
런타임에 객체의 동작을 선택할 수 있도록 하는 디자인 패턴

- 알고리즘을 사용하는 코드에서 세부 구현 정보를 분리 가능
- 런타임에 한 객체 내부에서 사용되는 알고리즘들을 전환 가능해 유연하고 동적으로 동작을 변경 가능
- 기존 코드를 수정하지 않고도 새로운 알고리즘으로 시스템을 쉽게 확장 가능
- 알고리즘이 몇 개밖에 되지 않고 거의 변하지 않는다면 사용하지 않는 편이 좋음

<br>

## 구조
<img src="https://refactoring.guru/images/patterns/diagrams/strategy/structure-indexed-2x.png?id=9f8e2f838f16705775411e2b4616820e" width="500px" alt="전략 패턴 구조">

### Context
Concrete Strategies 중 하나에 대한 참조를 유지하고 작업을 위임하는 클래스 또는 객체
- Strategy Interface를 통해서만 이 객체와 통신
- Client들이 런타임에 Context와 관련된 전략을 대체할 수 있도록 하는 세터​(setter)​를 노출함
- 작업 수행 방법에 대한 세부 정보를 몰라도 작업을 실행할 수 있는 통합된 방법을 제공

### Strategy Interface
모든 Concrete Strategies가 구현해야 하는 메서드 집합을 정의하는 인터페이스 또는 추상 클래스
- Context가 전략을 실행하는 데 사용하는 메서드를 선언
- 모든 전략이 동일한 규칙을 준수하고 Context에서 상호 교환적으로 사용할 수 있도록 보장하는 역할
- 공통 인터페이스를 정의함으로써 Context와 전략을 분리하여 설계의 유연성과 모듈화를 향상시킴

### Concrete Strategies
Strategy Interface에 정의된 작업을 수행하기 위한 특정 알고리즘 또는 동작을 제공
- Context가 사용하는 알고리즘의 다양한 변형들을 구현
- 각 알고리즘의 세부 사항을 캡슐화하고 작업을 실행하는 방법을 제공

### Client
특정 전략 객체를 만들어 Context에 전달
- 작업의 요구 사항을 파악하고 이러한 요구 사항에 따라 어떤 전략을 사용할지 결정
- 원하는 Concrete Strategies의 인스턴스를 생성하고 이를 Context에 전달하여 Context가 선택한 전략을 사용하여 작업을 수행할 수 있도록 해야함


## 전략 패턴을 적용하기 좋은 경우
- **일부 행동을 실행하는 방식에서만 차이가 있는 유사한 클래스들이 많은 경우**

    다양한 행동들을 별도의 클래스 계층구조로 추출하고 원래 클래스들을 하나로 결합해 중복 코드를 줄일 수 있게 해준다.
- **객체 내에서 한 알고리즘의 다양한 변형들을 사용하고 싶을 때, 그리고 런타임 중에 한 알고리즘에서 다른 알고리즘으로 전환하고 싶을 때**

    객체의 행동들을 특정 하위 행동들을 다양한 방식으로 수행할 수 있는 다른 하위 객체들과 연관시켜 객체의 행동들을 런타임에 간접적으로 변경할 수 있게 해준다.
- **서로 다른 동작을 선택하는 여러 조건문이 있는 클래스가 있는 경우**

    조건문을 없애고 코드를 보다 모듈화 및 유지 관리하기 쉽게 만드는 데 도움이 된다.
    <br>전략 패턴을 사용하면 모든 알고리즘을 같은 인터페이스를 구현하는 별도의 클래스들로 추출해 이런 조건문을 제거할 수 있다.
    원래 객체는 알고리즘의 모든 변형들을 구현하는 대신 이런 객체들 중 하나에 실행을 위임하면 된다.


<br><br>

#### Reference
- https://refactoring.guru/ko/design-patterns/strategy
- https://www.geeksforgeeks.org/strategy-pattern-set-1/
