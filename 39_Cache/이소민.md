# 캐시 
이전에 액세스한 데이터나 리소스를 저장하는 임시 저장소로 이전에 검색하거나 계산한 데이터를 효율적으로 재사용할 수 있다.
> 리소스란 웹 브라우저가 HTTP 요청으로 가져올 수 있는 모든 종류의 파일로 HTML, CSS, JS, 이미지, 비디오 파일 등이 해당된다.

메모리 계층 구조에서 캐시는 디스크나 메인 메모리보다 더 빠르게 데이터를 불러와서 사용해야할 때 쓰인다.<br/>
이러한 장점이 있는 만큼 단위 메모리당 비용이 비싼 편이기 때문에 재사용을 충분히 많이 하는 데이터만 선별적으로 캐싱하는 것이 좋다.

<image src="https://media.geeksforgeeks.org/wp-content/uploads/20230609020524/Memory-Hierarchy-Design.png">

### 장점
- 정적 리소스를 캐싱하여 반복적으로 다운로드하지 않고 캐시된 리소스를 빠르게 로드하여 페이지의 로딩시간을 단축할 수 있다.
- 동일한 요청에 대한 응답을 캐시를 통해 서버에서 가져오지 않고 로컬에서 처리함으로써 서버 부하를 줄일 수 있다.
- 즉 성능 향상, 자원 절약, 트래픽 감소를 통해 웹사이트나 애플리케이션의 성능을 최적화하는데 중요한 역할을 수행한다.

<br/>

## 사설 캐시(private), 공유 캐시(shared) 
- 사설 캐시
    - 개인 사용자의 브라우저나 디바이스 내에 위치한 캐시로 한명의 사용자만 사용
    - 사설 브라우저 캐시는 서버에 대한 추가적인 요청 없이 뒤로 가기나 앞으로 가기, 저장, 소스로 보기 등을 위해 방문했던 문서들을 사용할 수 있도록 해줌
    - ex. 장바구니 목록과 같은 개인화된 정보
- 공유 캐시
    - 한명 이상의 사용자가 재사용할 수 있도록 응답을 저장하는 캐시
    - 주로 프록시 서버나 CDN(Content Delivery Network)에 위치
    - 다수의 사용자에게 동일한 리소스 제공하기 위해 사용
    - ex. 웹페이지 이미지, css 파일

<br/>

## 브라우저 캐시 (HTTP 캐시)
- 브라우저나 HTTP 요청을 하는 클라이언트 애플리케이션에 의해 내부 디스크에서 이루어지는 캐시
- 단일 사용자를 대상으로 하는 Private 캐시로 해당 사용자의 정보만을 저장
- HTTP 캐시들은 일반적으로 GET에 대한 응답만을 캐싱

### http 캐싱 헤더
#### Cache-control
- 요청과 응답 내의 캐싱 메커니즘을 위한 디렉티브를 정하기 위해 사용
- 캐싱 디렉티브는 단방향성이며, 이는 요청 내에 주어진 디렉티브가 응답 내에 주어진 디렉티브와 동일하다는 것을 뜻하지는 않는다는 것을 의미

[ 캐시 능력 ]
- public
    - 응답이 어떤 캐시에 의해서든 캐시된다는 것을 의미
    - HTTP 인증, 혹은 보통 캐시 가능하지 않은 응답 상태 코드를 지닌 페이지가 캐시되어야 할 경우 유용
- private
    - 응답이 단일 사용자를 위한 것
    - 공유 캐시에 의해 저장되지 않아야 한다는 것
    - 사설 캐시는 응답을 저장할 수 있음
    - 응답을 캐싱하는 과정에서 엔드 유저만 캐싱이 가능하고, 그 가운데 거치는 매개체에서는 캐싱할 수 없음
- no-cache
    - 캐시된 복사본을 사용자에게 보여주기 이전에 재검증 위한 요청을 원 서버로 보내도록 강제
    - 캐시를 쓰지 않는 것이 아니라 캐시를 먼저 사용하기 이전에 서버에 해당 캐시를 사용해도 되는지 관해 검증 요청 보내는 속성. 
    - no-cache 없는 경우 캐시가 있다면 바로 캐시를 쓰지만 <br/>
    no-cache 속성 있다면 서버에 이 캐시 써도 되는지 허락 맡고 씀, 때문에 요청에 대한 시간 소요될 수 있음
- only-if-cached
    - 새로운 데이터를 내려받지 않음을 나타냄

[ 만료 ]
- `max-age=<seconds>`
    - 리소스가 최신 상태라고 판단할 최대 시간 지정
    - 캐시된 리소스가 유효한 시간(초 단위)
- `s-maxage=<seconds>`
    - max-age 또는 Expires 헤더를 재정의 하거나 <br/>
    프록시와 같은 공유 캐시에만 적용되며 사설 캐시에 의해서는 무시됨
- `max-stale[=<seconds>]`
    - 클라이언트 캐시의 만료 시간을 초과한 응답을 받아들일지를 나타냄
    - 초 단위 값을 할당할 수 있는데 이는 응답이 결코 만료되서는 안되는 시간을 나타냄
- `min-fresh<seconds>`
    - 클라이언트가 지정된 시간 동안 신선한 상태로 유지된 응답을 원한다는 것

[ 재검증, 리로딩 ]
- must-revalidate
    - 캐시는 사용하기 이전에 기존 리소스 상태를 반드시 확인해야하며 만료된 리소스는 사용하지 않아야 함
- proxy-revalidate
    - must-revalidate와 동일하지만 프록시와 같은 공유캐시에만 적용되며 사설 캐시에 의해서는 무시됨.
- immutable
    - 응답 본문이 계속해서 변하지 않을 것
    
[ 기타 ]
- no-store
    - 캐시는 클라이언트 요청 혹은 서버 응답에 관해서 어떤 것도 저장해서는 안됨
    - 때문에 요청 보낼 때마다 전체 데이터를 받아오는 식으로 처리
    - 개인정보와 같은 private 데이터가 있는 경우 해당 속성 사용

#### Expires
- 리소스 만료 일자 설정
- 0과 같은 유효하지 않은 날짜는 과거의 시간을 나타내며 리소스가 이미 만료되었음을 의미
- 응답 내에 "max-age" 혹은 "s-max-age" 디렉티브를 지닌 Cache-Control 헤더가 존재할 경우, Expires 헤더는 무시됨.

#### Etag - 강한 검증
- 특정 버전의 리소스를 식별하는 식별자
- 만약 특정 URL 의 리소스가 변경된다면, 새로운 ETag 생성됨.
- 서버는 클라이언트의 ETag를 현재 버전 리소스의 ETag와 비교하고, 두 값이 일치하는 경우(리소스에 변경이 없는 경우) 304 Not Modified 상태 반환. 이는 캐시된 버전이 여전히 유효함을 의미.
- Etag와 Http 헤더의 if-match를 사용하여 해시값을 비교, 해시값이 일치하지 않는다면 문서가 변경되었음을 의미, 412 에러 던짐 (Precondition Failed, 전제조건 실패)

#### Last-Modified - 약한 검증
- 서버가 Cache-Control 또는 Expires 헤더를 사용하여 명시적으로 유효성을 지정하지 않을 경우
Last-Modified 헤더를 찾음
- 원본 서버가 리소스가 마지막으로 수정되었다고 생각하는 날짜와 시간이 포함
- 리소스가 이전에 저장된 리소스와 동일한지 확인하기 위한 유효성 검사기로 사용. 
- ETag 헤더보다 정확하진 않지만 대비책으로 사용

<br/>

## 캐시 무효화
- 캐시된 정보가 유효하지 않을 때 즉시 캐시를 무효화하여 새로운 정보를 가져오도록 하는 것
- cache-control 헤더의 must-revalidate, no-cache, no-store 이용하여 무효화
- 서버에 새로운 데이터를 요청하여 업데이트 
- 리소스의 url에 버전번호를 추가하거나 쿼리 매개변수를 이용하여 리소스의 변경을 감지하고 새로운 버전을 가져옴

<br/><br/>

### 참고자료
- https://developer.mozilla.org/ko/docs/Web/HTTP/Caching
- https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Cache-Control
- https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/ETag
- https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Expires
- https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Last-Modified
- https://aws.amazon.com/ko/caching/
- https://toss.tech/article/smart-web-service-cache