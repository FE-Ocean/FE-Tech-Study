# 클로저 (Closure)
## 💡 함수와 그 함수가 선언된 렉시컬 환경과의 조합(MDN)

### 렉시컬 스코프 (Lexical Scope)
함수를 어디서 호출했는지가 아니라 **함수를 어디에 정의했는지**에 따라 상위 스코프를 결정

```js
const x = 1;

function foo() {
    const x = 10;
    bar();
}

function bar() {
    console.log(x);
}

foo(); 
```
위 예제의 `bar` 함수는 foo 함수 내에서 호출되지만, 정의는 전역에서 이루어졌다.
<br>자바스크립트는 렉시컬 스코프(정적 스코프)를 따르기 때문에 `bar` 함수의 상위 스코프는 전역이다.
<br>함수를 어디서 호출하는지는 함수의 상위 스코프 결정에 어떠한 영향도 주지 못한다.
<br><br> 


## 💡 자바스크립트 고유의 개념이 아닌 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 특성
<br><br> 


## 💡 함수가 정의될 때 상위 스코프 참조가 결정되는데, 그때 자신의 내부 슬롯인 [[Environment]]에 상위 스코프 참조를 저장

     내부 슬롯에 상위 스코프를 저장하기 때문에 실행 컨텍스트 스택에서 상위 스코프인 함수가 먼저 제거(생명주기가 끝나도)되어도 영향을 받지 않는다.
<br><br> 


## 💡 클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고, 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적
자바스크립트의 모든 함수는 상위 스코프를 기억하므로 이론적으로 모든 함수는 클로저다. 하지만 일반적으로 모든 함수를 클로저라고 하지는 않는다.

### 클로저가 아닌 예
1.
```js
function foo() {
    const x = 1;
    const y = 2;

    function bar() {
        const z = 3;

        console.log(z);
    }

    return bar;
}

const bar = foo();
bar();
```
- 중첩 함수 `bar`는 외부 함수 `foo`보다 더 오래 유지되지만
<br>상위 스코프인 `foo` 함수의 어떠한 상수(식별자)도 참조하고 있지 않기 때문에 클로저라고 할 수 없다.

2.
```js
function foo() {
    const x = 1;

    function bar() {
        console.log(x);
    }
    bar();
}

foo();
```
- 중첩 함수 `bar`는 상위 스코프의 식별자를 참조하고 있지만 외부 함수 foo보다 생명 주기가 짧다.
- `bar`는 클로저였지만 외부 함수보다 일찍 소멸되기 때문에
<br>생명 주기가 종료된 외부 함수의 식별자를 참조할 수 있다는 클로저의 본질에 부합하지 않아 일반적으로 클로저라고 하지 않는다.
<br><br> 

## 💡 클로저는 상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용함

<br><br> 


#### Reference
- 책 <모던 자바스크립트 Deep Dive>
- https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures