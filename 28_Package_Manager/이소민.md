# 패키지 매니저란
- 패키지 관리 작업을 자동화, 안전처리 하기 위해 사용되는 도구 
- 패키지는 소프트웨어 실행파일, 라이브러리, 설정파일, 버전번호, 체크섬 등 코드의 배포를 위해 사용되는 코드모음
- 패키지 매니저 설치 시 메타데이터는 로컬 패키지 데이터베이스에 저장됨
- 패키지 매니저는 일반적으로 소프트웨어 불일치, 존재하지 않은 필수 항목을 방지하기 위해 소프트웨어 의존성과 버전 정보의 데이터베이스를 유지보수함 

<br/>

## 패키지 매니저의 역할
- 소프트웨어 설치, 업데이트, 제거 쉽게 수행 가능
- 의존성 관리
    - 의존성이란 어떤 패키지를 동작하기 위해서 필수적으로 필요한 다른 패키지
    - 프로젝트가 필요로 하는 외부 라이브러리, 모듈 및 프레임워크를 관리 
    - 패키지 매니저는 의존성을 쉽게 설치하고 업데이트할 수 있도록 도와줌
- 보안 업데이트
    - 패키지 매니저는 시스템의 소프트웨어를 최신 상태로 유지 
    - 보안 패치와 업데이트를 자동으로 검색하고 적용하여 시스템의 안전성을 유지
- 패키지 검색 및 설치
    - 패키지를 검색하고 원하는 패키지를 쉽게 설치 가능.
    - 패키지 목록, 설명, 버전 정보 등 확인 가능

<br/>


## 프론트엔드에서 사용되는 패키지 매니저
### npm (Node Package Manager)
- Node.js와 함께 제공되는 기본 패키지 매니저
- JavaScript 및 Node.js 프로젝트에서 사용되며, package.json 파일을 통해 의존성과 스크립트를 관리
- 많은 패키지와 모듈이 npm 레지스트리에서 호스팅되어 있어 프로젝트에 쉽게 추가할 수 있음
- npm install 명령어를 사용하여 패키지를 설치하고, npm update로 패키지를 업데이트할 수 있음

문제점
- 일관적이지 않은 패키지 버전
    - node_modules는 기본적으로 시멘틱 버저닝(Semantic Versioning)이라는 기법을 사용해 사용하는 모듈 버전을 나타낼 것을 권장함.
    > - 시멘틱 버저닝이란? <br/>
    `"react":"16.8.6" `<br/>
        - 첫번째 숫자는 이전 버전과의 호환, 숫자가 다르면 두 버전은 아예 호환되지 않는 버전 <br/>
        - 두번째 숫자는 업데이트에 새로운 기능이 추가되었을 때  <br/>
        - 세번째 숫자는 간단한 버그 패치가 있었을 경우  <br/>
    - npm install을 통해 모듈 설치하면 최신 버전을 다운 받기 때문에 버전 불일치 문제 발생 가능
- 고정되지 않은 설치 순서
    - 이미 만들어진 프로젝트에서 모듈을 추가 설치할 경우,<br/> 
    개발자가 어떤 순서로 모듈을 의존성에 추가했는지 상관없이 npm은 모듈이름을 사전 순서대로 정렬해 순차적으로 설치함. 
- 순차적 설치로 인한 긴 소요시간
    - 모듈을 한번에 하나씩만 순차적으로 설치하기 때문에 설치해야하는 모듈 많아질수록 설치시간 길어짐. 

<br/>

### yarn
- Facebook에서 개발한 JavaScript 및 Node.js 프로젝트용 패키지 매니저
- npm보다 빠르고 안정적인 패키지 설치를 제공
    - yarn은 캐시를 사용하기 때문에 한 번 다운로드한 패키지라면 다음부터는 빠른 속도로 설치할 수 있음
    - 인터넷 연결되지 않은 환경에서도 설치 가능
    - 병렬 설치를 지원하여 더 빠른 의존성 설치가 가능
- yarn.lock 파일을 사용하여 의존성 버전을 정확하게 고정.
    -  다른 사용자가 프로젝트를 개발할때 항상 같은 버전의 모듈을 사용할 수 있도록 보장 
- yarn add 및 yarn upgrade 명령어로 패키지를 추가하고 업데이트할 수 있음.
- checksum을 사용하여 패키지 설치 확인 - 패키지 파일 무결성 확인 가능한 것

<br/>


### yarn berry
<image src="https://static.toss-internal.com/ipd-tcs/toss_core/staging/5cc6bed3-b1c6-428a-b250-8ed0b8e6551a">

#### npm의 문제점
1. 비효율적인 의존성 검색
2. 환경에 따라 달라지는 동작
- npm은 패키지를 찾지 못하면 상위 디렉토리인 node_modules 폴더를 계속 검색함. <br/>
때문에 해당 패키지의 상위 디렉토리 환경에 따라 가져오는 의존성이 달라질 수 있음.
3. 비효율적인 설치
- node_modules 폴더는 복잡하기 때문에 설치가 유효한지 검증하기 어려움.<br/> 
때문에 yarn classic과 npm은 기본적인 의존성 트리의 유효성까지만 검증하고 각 패키지의 내용이 올바른지 확인하지 않음
4. 유령 의존성
<image src="https://static.toss-internal.com/ipd-tcs/toss_core/staging/90646656-6012-4da1-95b4-f4b7479beb50">
- 왼쪽 의존성 트리의 경우 중복되는 패키지로 디스크 공간이 낭비됨
- npm, yarn classic에서는 중복해서 설치되는 node_modules를 아끼기 위해 호이스팅 기법을 사용. 
- 호이스팅한 오른쪽 트리의 경우 직접 의존하고 있지 않은 라이브러리를 require()할 수 있는데 이를 '유령 의존성' 이라고 함
- 유령 의존성 현상 발생할 때 package.json에 명시하지 않은 라이브러리를 조용히 사용할 수 있게됨. 
- 이는 곧 다른 의존성을 package.json에서 제거했을 때 소리없이 같이 사라진다는 것을 의미하기 때문에 의존성 관리 시스템을 혼란스럽게함. 


#### yarn berry 특징
- Plug'n'Play 전략
    - node_modules 생성하지 않고 .yarn/cache 폴더의 의존성 정보가 저장되고 .pnp.cjs 파일에 의존성 찾을 수 있는 정보 기록됨. 
- ZipFS(Zip Filesystem) - zip으로 묶인 라이브러리가 저장된 .yarn/cache 폴더 
    - zip으로 묶인 라이브러리가 저장된 .yarn/cache 폴더 -> 각 의존성이 zip 아카이브로 관리됨. 
    - 더이상 node_modules 디렉토리 구조 생성할 필요없기 때문에 설치가 신속해짐
    - 각 패키지는 버전마다 하나의 zip 아카이브만 가지기 때문에 중복해서 설치되지 않음
    - 의존성을 구성하는 파일 수가 많지 않기 때문에 변경사항 감지하거나 전체 의존성 삭제하는 작업이 빠름
- 플러그인 아키텍처를 도입하여 Yarn의 기능을 확장하고 사용자 정의할 수 있음.
- TypeScript로 작성되었으며, TypeScript 프로젝트에서 더 원활하게 작동.
- 개선된 작업 흐름과 스키마 레벨의 자동 누수 검출을 제공.
```
$ npm install -g yarn // npm에서 최신버전 yarn 내려받기
$ cd ../path/to/some-package 
$ yarn set version berry // 버전 berry로 설정
```


### 참고자료
https://ko.wikipedia.org/wiki/%ED%8C%A8%ED%82%A4%EC%A7%80_%EA%B4%80%EB%A6%AC%EC%9E%90<br/>
https://toss.tech/article/node-modules-and-yarn-berry