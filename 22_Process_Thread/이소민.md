## Process
- 운영체제로부터 자원을 할당받은 작업의 단위 
- 프로그램은 컴퓨터에서 실행할 수 있는 파일로, 파일을 실행하지 않은 상태를 지칭
- 프로세스는 이러한 정적인 프로그램이 돌아가고 있는 상태를 말함, 즉 ***작업중인 프로그램이 프로세스***
<br/>
    > #### cpu를 할당한다?
    > 운영체제가 실행할 프로세스에게 CPU의 실행시간을 주는 것. 

<br/>

### Process 자원구조
1. code 
    - 프로그래머가 작성한 프로그램 함수들의 코드가 CPU가 해석 가능한 기계어 형태로 저장
2. data  
    - 코드가 실행되면서 사용하는 전역 변수나 각종 데이터들이 모여있다. 데이터영역은 .data /.rodata / .bss 영역으로 세분화 
3. stack 
    - 지역 변수와 같은 호출한 함수가 종료되면 되돌아올 임시적인 자료를 저장하는 독립적인 공간. 
    - stack은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸. 
    - 만일 stack 영역을 초과하면 stack overflow 에러 발생.
4. heap 
    - 생성자, 인스턴스와 같은 동적으로 할당되는 데이터들을 위해 존재하는 공간. 
    - 사용자에 의해 메모리 공간이 동적으로 할당되고 해제
    - 각 프로세스는 별도의 주소 공간에서 실행되며, 서로 독자적인 메모리 공간을 갖기 때문에 서로 메모리 공간을 공유할 수 없음. 

    > #### 프로세스 간 정보 공유하는 방법
    > 1. IPC(Inter-Process Communication) 사용
    > 2. LPC(Local inter-Process Communication) 사용
    > 3. 별도로 공유 메모리를 만들어서 정보를 주고받도록 설정
    > 
    > but 프로세스 자원 공유는 단순히 CPU 레지스터 교체뿐만이 아니라 RAM과 CPU 사이의 캐시 메모리까지 초기화되기 때문에 자원 부담이 크다는 단점이 있음.
    다중 작업의 경우 스레드를 이용하는 것이 효율적이기 때문에 현대 컴퓨터의 운영체제에선 다중 프로세싱을 지원하고 있지만 다중 스레딩을 기본으로 함.

<br/>

## Thread
- 경량화된 프로세스 버전, 스레드 
- 프로세스가 할당받은 자원을 이용하는 실행 단위
- 스레드는 프로세스 내에서 동시에 진행되는 작업 흐름의 단위
- 프로세스를 생성하면 기본적으로 하나의 main 스레드가 생성
- 스레드 수가 많을 수록 당연히 프로그램 속도도 동시에 하는 작업이 많아져 성능이 올라감.

### Thread의 자원 공유
- 스레드는 독자적인 stack을 할당받으며 code, data, heap 영역은 process내의 다른 스레드와 공유
- 이 때문에 스레드가 프로세스 실행 흐름의 일부가 되기 때문에 동시 작업이 가능
- 독자적인 stack이 있다는 것은 독립적인 함수 호출이 가능하다는 것으로 이는 곧 독립적인 실행 흐름을 가질 수 있음을 의미.
- 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있음.

<br/>

## 병렬성과 동시성
### 병렬성
직관적으로 명령어를 메모리에서 뽑아 해석하고 실행하는 반도체 유닛인 여러개의 코어에 맞춰 여러개의 프로세스, 스레드를 돌려 병렬로 작업들을 동시 수행하는 것. 이 때 동시 수행의 의미는 정말 ***같은 시점에 작업을 실행***시키는 것. 


### 동시성
둘 이상의 작업이 동시에 실행되는 것을 의미. 이는 ***동시에 실행하는 것처럼 보이게 하는*** 것으로 물리적으로 동시에 실행하는 병렬성과 다름. 

프로세스들을 ​번갈아가면서 매우 빠르게 처리함으로써 마치 동시에 돌아가는 것처럼 보이게 하는 것. 이는 여러 작업을 동시에 처리하는 것처럼 보이게 만들어, 사용자에게 더 빠른 반응성을 제공하기 위함. 이렇게 진행 중인 작업들을 번갈아 바꾸는 것을 ***Context Switching*** 이라고 함.

<br/>

## Process Context Switching
- CPU는 한 번에 하나의 프로세스만 실행할 수 있기 때문에 여러 개의 프로세스를 번갈아가며 실행하여 CPU 활용률을 높이기 위해 컨텍스트 스위칭이 필요
- 컨텍스트 스위칭이란 동작 중인 프로세스가 대기를 하면서 *해당 프로세스의 상태(Context)를 보관*하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말함. 
- 컨텍스트 스위칭이 일어날 때 다음 실행될 프로세스는 스케줄러가 결정.

### PCB (Process Control Block)
- 프로세스의 상태를 보관하는 임시 저장소
- 컨텍스트 스위칭할 때 기존 프로세스 상태를 저장해두어야 다음에 똑같은 작업을 할 수 있기 때문에 필요.
- 운영체제는 PCB에 담긴 프로세스 고유 정보로 프로세스의 실행상태 파악, 우선순위 조정, 스케줄링 수행, 다른 프로세스와 동기화를 제어함.
- 프로세스 생성시 메모리에 해당 프로세스의 PCB가 생성, 프로세스 종료시 삭제.

<br/>

## Thread Context Switching
멀티 스레딩 환경에서 스레드 간의 실행을 전환하는 기술

### TCB (Thread Control Block)
- 스레드마다 운영체제에서 유지하는 스레드에 대한 정보를 담고있는 자료구조
- PCB안에 들어있으며 스레드 생성시 운영체제에 의해 생성되며 스레드 소멸시 함께 소멸.

<br/>


### 프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭
#### 공통점
- 두가지 모두 멀티태스킹 환경에서 여러 프로세스와 스레드를 동시에 실행하기 위한 기술

#### 차이점
- 스레드들은 text, data, heap 영역 메모리를 공유하기 때문에 TCB에서는 stack및 간단한 register 포인터 정보만 저장해 PCB보다 가벼워 더 빨리 읽고 쓸 수 있음.

- 프로세스 컨텍스트 스위칭이 일어날 경우 다른 프로세스 실행으로 CPU가 새로운 명령어와 데이터를 로드해야하기 때문에 CPU 캐시 메모리를 초기화 해야하지만 <br/>
스레드 컨텍스트 스위칭의 경우 프로세스 내 스레드 간 stack과 register값 등 일부 정보만 변경되기에 CPU 캐시 메모리가 초기화되지 않음. (스레드가 서로 다른 cpu 코어에서 실행될 때는 해당 코어 캐시 메모리에 스레드 컨텍스트 정보가 로드되어야하기 때문에 CPU 캐시 메모리가 초기화될 수 있음.)

<br/>

#### 굳이 작업을 나눠서 수행해야할까? 
- 하드웨어적 한계
CPU 발열 때문에 *오버클럭으로 성능을 올리기에는 한계가 있기 때문에 코어의 성능을 올리는 대신 쿼드코어, 옥타코어 CPU를 출시하고 있음. 이는 단일 코어의 클럭 속도를 극단적으로 올리는 것보다 전력 소모와 발열 문제를 덜 겪을 수 있는 방법으로 다중 코어 프로세서들은 병렬 처리 능력을 통해 멀티태스킹 작업과 복잡한 작업을 더 효율적으로 처리할 수 있음. 하지만 이 역시 코어를 계속해서 늘릴 수 없기 때문에 하드웨어적 한계가 있음.

- 논리적인 효율
만약 논리적 코어가 8개라면 최대 8개 작업을 동시에 실행할 수 있음. 이때 20개의 작업을 처리해야하고, 그중 8개가 무거운 작업이고 무거운 작업 8개를 먼저 동시에 처리한다고 가정한다면 나머지 12개의 가벼운 작업은 8개의 작업이 끝날때까지 대기해야함. 때문에 효율적인 측면에서 작업을 나눠 번갈아 처리하는 동시성 개념을 사용하는 것.

    > #### * 오버클럭이란 ? 
    > 컴퓨터의 중앙 처리 장치(CPU)나 그래픽 카드와 같은 하드웨어 구성 요소의 작동 속도를 제조사가 권장하는 기본 클럭 속도 이상으로 증가시키는 것을 의미. 이를 통해 해당 하드웨어의 성능을 높이는 것이 가능, 오버클럭은 보다 높은 발열과 전력 소모를 초래할 수 있으며, 불안정한 시스템 동작으로 인해 갑작스러운 시스템 충돌이 발생할 수도 있음. 또한, 오버클럭을 적용하면 하드웨어의 수명이 줄어들 수도 있음.

<br/>
<br/>


### 참고 자료 
https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4



