## 1. 시간복잡도
- 입력의 크기와 문제를 해결하는데 걸리는 시간의 상관관계.
- 시간 초과 여부를 확인하기 위해 '핵심이 되는 연산'을 찾는 것.
- 최악의 경우를 복잡도로 이야기 함.


>만약 크기 n의 모든 입력에 대한 알고리즘에 필요한 시간이 최대 5n^3 + 3n의 식을 가진다면 이 알고리즘의 점근적 시간 복잡도는 O(n^3)이라고 할 수 있다.
시간 복잡도는 기본적인 연산을 수행하는데에 어떤 고정된 시간이 걸릴 때, 알고리즘에 의해서 수행되는 기본 연산의 개수를 세어 예측할 수 있다. 
그러므로 걸리는 시간의 총량과 알고리즘에 의해 수행되는 기본적인 연산의 개수는 최대 상수 인자만큼 다르다.
알고리즘의 수행 시간은 동일 크기의 다양한 입력에 의해 달라질 수 있기 때문에, 가장 많이 쓰이는 **최악의 시간 복잡도**의 알고리즘 시간을 T(n)이라고 했을 때, 이것은 크기 n의 모든 입력에 대해 걸리는 최대의 시간으로 정의할 수 있다.

<br/>

<image src="https://velog.velcdn.com/images/miniso/post/01e000ba-6aa8-45d4-b0d2-c3e1a1998737/image.png" width="600px"> <br/>

<br/>

## 2. 시간 복잡도를 표기하는 '빅오 표기법'
주어진 식을 값이 가장 큰 대표항만 남겨서 나타내는 방법
### 2-1. O(1)
- 상수 시간 
- 입력값의 크기와 상관없이 실행 시간 일정

### 2-2. O(log n)
- 로그 시간
- 이러한 알고리즘은 보통 이진 탐색과 같은 **분할 정복 알고리즘**에서 사용

### 2-3. O(n)
- 선형 시간
- 입력값 증가와 같은 비율로 시간이 증가하는 것
- 대부분의 **반복문**이 이러한 시간 복잡도를 가짐

### 2-4. O(n log n)
- 선형 로그 시간
- 효율적인 정렬 알고리즘인 **퀵소트와 머지소트**에서 사용

### 2-5. O(n^2)
- 이차 시간
- 입력값 크기의 제곱에 비례하여 시간이 증가
- 보통 **중첩된 반복문**이 사용되는 경우에 발생

### 2-6. O(2^n)
- 지수 시간
- 보통 **재귀적으로 호출되는 알고리즘**에서 발생, 실행 시간이 매우 급격하게 증가

### 2-7. O(n!)
- 팩토리얼 시간
- 입력의 크기에 대해 팩토리얼 함수에 비례하여 실행 시간이 증가하는 알고리즘
- n부터 1까지 모든 수를 곱하는 연산을 수행하기 때문에 입력 크기가 커질수록 지수적으로 증가.
- n이 11이하 정도로 작은게 아니라면 시간 제한 통과하기 힘듦
- 빅오표기법에서 가장 느린 시간복잡도를 나타냄


<br/>
<br/>

### [ 참고자료 ]
위키백과 - 시간 복잡도 https://ko.wikipedia.org/wiki/%EC%8B%9C%EA%B0%84_%EB%B3%B5%EC%9E%A1%EB%8F%84 <br/>
바킹독 - 기초코드작성요령 https://www.youtube.com/watch?v=9MMKsrvRiw4 <br/>
이미지 - https://www.bigocheatsheet.com/ <br/>
https://hanamon.kr/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-time-complexity-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/


