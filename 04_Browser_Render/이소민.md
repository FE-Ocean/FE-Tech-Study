## 웹 브라우저의 기본적인 구조
<img src="https://d2.naver.com/content/images/2015/06/helloworld-59361-1.png" width="300px"><br/>

#### 사용자 인터페이스
- 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분, 사용자와 상호작용
#### 브라우저 엔진
- 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어
#### 렌더링 엔진
- HTML과 CSS를 파싱하여 요청한 웹페이지를 표시
#### 통신
- 각종 네트워크 요청 수행
#### 자바스크립트 해석기
- 자바스크립트 코드를 해석하고 실행
#### UI 백엔드
- 체크박스나 버튼과 같은 기본적인 위젯을 그려줌, OS에 의존하는 UI형태
#### 자료 저장소
- WebStorage(LocalStorage, SessionStorage), Cookie

<br/>
<br/>

## 브라우저 렌더링 시뮬레이션

### 1. 브라우저 검색창에 url 주소 입력 
`https://www.naver.com/` 입력했다고 가정

### 2. 입력한 정보 확인
입력한 것이 검색어인지, url 주소인지 확인, <br/>
url 주소를 입력했으므로 브라우저 엔진에서 네트워크 호출

### 3. 네트워크 호출
#### 3-1. ip 주소 찾기
1. 클라이언트는 DNS 서버에서 서버 주소 찾기 전에 캐싱된 DNS기록을 먼저 확인
2. 만약 해당 도메인에 맞는 ip주소 존재한다면<br/>
DNS 서버에 도메인에 해당하는 ip 주소 요청하지 않고 캐싱된 ip주소 바로 반환
3. DNS 기록에 도메인과 일치하는 ip주소 없다면 DNS 서버에 해당 사이트 ip 주소 요청

* DNS (domain name server) : 도메인 주소에 대응하는 ip 주소 찾아주는 역할

#### 3-2. ip 주소 찾았으니 데이터를 받아보자
클라이언트 브라우저는 네이버 서버에 HTTP Request를 보내 데이터를 요청하고<br/>
request 받은 네이버 서버는 클라이언트로 HTTP Response를 보내 데이터를 보냄 

### 4. 데이터를 받았으면 화면에 그려야지 ! **브라우저 렌더링 과정**
#### 4-1. **파싱**
서버로부터 받은 데이터(HTML, CSS)는 브라우저가 이해할 수 없음.<br/> 
때문에 파싱하여 브라우저가 이해할 수 있는 DOM, CSSOM으로 변환<br/>
파싱하다가 `<script>` 태그 만나게 되면 DOM 파싱 중단하고 자바스크립트를 해석하여 DOM에 영향을 미치는 것들을 반영.

#### 4-2. **렌더 트리 생성**
변환된 DOM, CSSOM은 렌더링을 위해 렌더 트리로 결합됨.<br/>
렌더 트리는 렌더링을 위한 트리 구조의 자료 구조로, 브라우저 화면에 렌더링 되는 노드만으로 구성되며<br/>
화면에 렌더링 되지 않는 노드(meta태그, script태그)와 css에 의해 비표시 되는 노드(display:none)들은 포함하지 않음.

#### 4-3. **레이아웃 과정; 배치**
렌더 트리의 렌더러들은 크기와 위치 정보를 가지고 있지 않은 상태.<br/>
렌더 트리를 기반으로 각 노드의 위치, 크기, 높이, 너비 등을 계산하여 노드들을 배치.
    
#### 4-4. **페인트**
지금까지 계산된 정보를 바탕으로 한페이지를 여러개의 레이어로 나눈뒤 시각적인 부분을 화면에 그려줌.
* 그리는 순서
    1. background-color
    2. background-image
    3. border
    4. children
    5. outline
#### 4-5. **컴포지팅**
브라우저 렌더링 과정에서 화면에 그려진 요소들을 조합하여 최종 출력물을 생성하는 과정.<br/> 
페인팅 단계에서 나눠진 레이어를 스크린에 픽셀로 표현하고, 한페이지로 합성함.<br/>
이 과정에서 z-index, 투명도, 애니메이션 등의 요소가 고려됨.

### 5. 네이버 화면이 짠!

<br/>
<br/>

## ** 리플로우, 리페인트 ?? 
### 리플로우 (레이아웃 단계 다시)
생성된 DOM 노드의 레이아웃 수치(너비, 높이, 위치 등) 변경 시<br/>
영향 받은 모든 노드의 수치를 다시 계산하여 렌더 트리를 재생성하는 것.

<br/>

### 리페인트 (페인트 단계 다시)
재결합된 렌더 트리를 기반으로 다시 페인트를 하는 것, 레이아웃 수치가 변경되어야지만 리페인트가 발생하는 것은 아님. <br/>
노드의 background-color, visibility, outline등 레이아웃에 영향이 없는 변경은 리플로우 없이 리페인트만 일어남.<br/>
즉, 레이아웃과 관련없는 스타일이 변경될 경우 페인트 단계가 다시 실행되는 것.

<br/>
렌더링 과정은 순차적으로 진행됨. 각각의 과정들은 전 단계의 데이터가 필요하기 때문에 전 단계에 변화가 일어날 경우 다음 단계에 모두 영향을 미침.<br/>
때문에 리플로우, 리페인트 해야할 요소가 많아질수록 자연스러운 애니메이션을 그리지 못하고, 브라우저의 전체적인 성능에 영향을 미치게 됨.<br/>
( https://csstriggers.com/
에서 브라우저 엔진에 따른 레이아웃, 페인트 실행 여부를 확인할 수 있음.)

<br/>
<br/>
<hr/>

### [ 참고자료 ]
네이버 D2 https://d2.naver.com/helloworld/59361<br/>
우아한테크 - [10분 테코톡] 체프의 브라우저 렌더링 https://www.youtube.com/watch?v=sJ14cWjrNis