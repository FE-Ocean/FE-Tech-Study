# 가비지 컬렉션 (Garbage collection, GC)
**프로그램에서 할당되었지만 더 이상 참조되지 않는 메모리(가비지)를 회수하려고 시도하는 자동 메모리 관리의 형태**
- 다른 객체에서 더 이상 참조하지 않는 객체를 찾아 삭제하는 과정
- C, C+ 같은 언어와 달리 개발자가 수동으로 메모리를 할당 해제할 필요가 없도록 해줌
- 메모리 누수 방지 가능
- 1959년경 미국의 컴퓨터 과학자 존 매카시가 Lisp에서 수동 메모리 관리를 간소화하기 위해 발명

<br>

## 자바스크립트의 가비지 컬렉션 기준
자바스크립트 엔진 내에서 가비지 컬렉터가 끊임없이 동작해 모든 객체를 모니터링하고, 도달할 수 없는 객체는 삭제한다.
도달 가능성(reachability)이라는 개념을 기준으로 메모리 관리를 수행한다.

### 도달 가능한 값
> **도달 가능한(reachable) 값**: 어떻게든 접근하거나 사용할 수 있는 값을 의미

- 루트 (root)

    태생부터 도달 가능하기 때문에, 명백한 이유 없이는 삭제되지 않는다.
    - 현재 함수의 지역 변수와 매개변수
    - 중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수
    - 전역 변수
    - 기타 등등

- 루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값


### 알고리즘
#### Reference-counting
> ***최신 자바스크립트 엔진은 더 이상 사용하지 않는다.***

다른 객체에게 몇 번 참조가 되는지 세어서, 객체를 가리키는 참조가 0이면 삭제하는 방식
- **순환 참조**하게 되면 두 객체 각각을 가리키는 참조가 하나 이상 있기 때문에 참조가 0이 되지 않아 메모리 누수의 원인이 됨

#### Mark-and-sweep
아직 필요한 객체만 마크하고, 마크 되지않은 거은 삭제하는 방식. 루트에서 닿지 않는 객체를 지운다.

- 작동 과정

    1. 가비지 컬렉터가 루트 정보를 수집하고 이를 mark(기억) 한다.
    2. 루트가 참조하고 있는 모든 객체를 방문하고 이것들을 mark 한다.
    3. mark 된 모든 객체에 방문하고 그 객체들이 참조하는 객체도 mark 한다. 한번 방문한 객체는 전부 mark 하기 때문에 같은 객체를 다시 방문하는 일은 없다.
    4. 루트에서 도달 가능한 모든 객체를 방문할 때까지 위 과정을 반복한다.
    5. mark 되지 않은 모든 객체를 메모리에서 삭제한다.

- 참조가 0인 객체에는 닿을 수 없기에 순환 참조 문제 해결 가능
- 현재 모든 최신 엔진은 Mark-and-sweep 가비지 컬렉터를 제공

<br>

## V8 엔진의 가비지 컬렉션
### 힙(Heap) 메모리
<img scr="https://miro.medium.com/v2/resize:fit:1584/0*SM_Ja0xN9q54Lpqf.png" width="500px" alt="Resident Set">

V8 엔진은 힙 메모리에 객체나 동적 데이터를 저장하고, 힙 메모리는 가비지 컬렉션이 발생하는 곳이다.
힙 메모리 전체에서 가비지 컬렉션이 실행되는 것은 아니고 Young과 Old 영역에서만 실행된다.
힙 메모리는 위 그림과 같이 더 세부적으로 나눌 수 있다.

- **New space** (Young generation)

    새로 만들어진 모든 객체를 저장. 이 객체들은 짧은 생명 주기를 가짐
    - 크기가 작고 같은 2개의 세미(semi) 영역을 가짐
    - 이후에 살펴볼 스캐벤져(Scavenger, 마이너 GC)가 관리
- **Old space** (Old generation)

    마이너 GC가 두 번 발생할 동안 New space에서 살아남은 객체들이 이동하는 영역
    - 이후에 살펴볼 메이저 GC(Mark-Sweep 및 Mark-Compact)가 관리
    - 이 영역은 다시 2개의 영역으로 나누어진다.

        - Old 포인터 영역: 살아남은 객체들을 가지며, 이 객체들은 다른 객체를 참조
        - Old 데이터 영역: 데이터만 가진 객체들(다른 객체를 참조하지 않는다)을 가짐. 문자열, 박싱(boxing)된 숫자, 실수형(double)로 언박싱(unboxing)된 배열은 마이너 GC가 두 번 발생하면서 New space에서 살아남아 이 영역으로 이동

<br>

### 가비지 컬렉션 메커니즘
V8 엔진은 가비지 컬렉션을 사용해 힙 메모리를 관리한다.
서로 다른 상황과 목적을 위해 설계된 가비지 컬렉션 과정이 있다.

#### Minor GC
- 마이너 GC는 New 영역을 작고 깨끗하게 유지시킴
- 객체들은 New 영역에 할당되고 크기가 매우 작아(상황에 따라 1~8MB를 차지) New 영역에 할당 비용은 매우 저렴
- 스캐벤저(Scavenger)

    할당 비용이 저렴한 건 새 객체에 대한 공간을 예약하려고 할 때마다 증가하는 할당 포인터가 있기 때문이다.
    이 할당 포인터가 New 영역의 마지막에 도달하면, 마이너 GC가 발생한다. 이 과정이 스캐벤저.
    - 스캐벤저는 매우 자주 발생하고 병렬 헬퍼 스레드를 사용하며, 굉장히 빠르다.
- New 영역은 크기가 같은 2개의 세미 영역으로 나뉘며, To 영역과 From 영역이다. 대부분의 할당은 To 영역에서 만들어지고, To 영역이 가득 차면 마이너 GC가 발생한다.


#### Major GC
- V8 엔진에서 Old 영역의 메모리가 충분하지 않다고 판단될 때 발생
- Old 영역을 작고 깨끗하게 유지시킴
- 동적으로 계산된 크기에 기반하며, 마이너 GC 주기에서 채워짐


### stop-the-world
GC를 수행하는 동안 애플리케이션 실행을 멈추는 현상

이를 피하기 위해 V8엔진에서는 다음과 같은 기술을 사용한다.
- 점진적 GC(Incremental GC)

    가비지 컬렉션을 여러 부분으로 분리한 다음, 각 부분을 별도로 수행한다. 작업을 분리하고, 변경 사항을 추적하는 데 추가 작업이 필요하긴 하지만, 긴 지연을 짧은 지연 여러 개로 분산시킬 수 있다는 장점이 있다.
- 동시 마킹(Concurrent marking)

    마킹은 자바스크립트 메인 스레드에 영향을 주지 않고 다중 헬프 스레드를 사용해 동시에 수행된다.
- 동시 스위핑/압축(Concurrent sweeping/compacting)

    스위핑과 압축은 자바스크립트 메인 스레드에 영향을 주지 않고 헬퍼 스레드에서 동시에 수행된다.
- 레이지 스위핑(Lazy sweeping)

    메모리가 필요할 때까지 페이지에서 가비지 삭제를 지연시킨다.

- 유휴 시간 수집(idle-time collection)

    가비지 컬렉터는 실행에 주는 영향을 최소화하기 위해 CPU가 유휴 상태일 때에만 가비지 컬렉션을 실행한다.


<br><br>

#### Reference
- https://ko.javascript.info/garbage-collection
- https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)
- https://ui.toast.com/weekly-pick/ko_20200228
- https://developer.mozilla.org/ko/docs/Glossary/Garbage_collection
