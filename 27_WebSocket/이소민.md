# 웹소켓 WebSocket
- 클라이언트와 서버를 연결하고 실시간으로 통신이 가능하도록 하는 통신 '프로토콜'
- TCP 연결 기반으로 서버와 유저가 양방향 통신 가능
- http의 경우 단방향 통신으로 클라이언트의 request과 서버의 response을 주고 받는 방식으로 동작 
- 반면 웹소켓은 socket connection을 open, close
- 커넥션 오픈되면 서버는 클라이언트가 요청하지 않아도 업데이트를 원하는 때에 데이터를 보낼 수 있음

<br/>

## 1. 웹소켓 특징
### 1-1. 양방향 통신
- 데이터 송수신을 동시에 처리할 수 있음
- http 통신은 클라이언트가 서버에게 요청을 보내는 경우에만 서버가 응답하는 단방향 통신

### 1-2. 실시간 네트워킹
- 웹 환경에서 연속된 데이터를 빠르게 노출 (채팅, 주식, 코인 등)
- 여러 단말기에 빠르게 데이터를 교환해야할 때 

### 1-3. 상태 유지(Stateful) 프로토콜 
- http는 무상태성이기에 상태를 저장하지 않지만 <br/>웹소켓은 stateful 프로토콜이기 때문에 한번 연결 이루어지면 해당 연결을 이용해 통신 <br/>
- 이러한 특징으로 더 빠른 통신이 가능할 뿐만 아니라 TCP 커넥션 비용을 아낄 수 있음. 

### 1-4. 많은 메모리 파워 필요
- 웹소켓은 서버에서 연결된 클라이언트의 상태를 추적하기 때문에 클라이언트 수가 많을수록 더 많은 메모리 필요. 
- 웹소켓은 클라이언트와 서버간의 지속적인 연결을 유지하며, 메세지를 실시간을 주고 받기 때문에 서버의 빠른 응답 시간을 필요로함.<br/> 하지만 서버에 이미 수많은 커넥션이 오가고 있다면 서버 부하가 증가할 수 있음.
- -> 많은 유저를 수용하기 위해 서버의 확장이 필요해질 수 있음 

### 1-5. 웹 브라우저 지원
- 브라우저에는 내장된 websocket api가 있음
- 웹 어플리케이션에서 클라이언트측 웹소켓을 쉽게 구현할 수 있음 
- 웹소켓은 어떤 프로그래밍 언어에 국한되어 있는 것이 아닌 그저 '프로토콜'

<br/>
<hr/>

### ✦ webRTC (P2P 커뮤니케이션)
- 웹소켓의 특징 중 많은 메모리 파워가 필요하다는 특징을 해결하기 위한 방법
- 서버를 거치지 않고 브라우저 끼리 데이터를 교환할 수 있음
- 단순 텍스트 뿐만 아니라 영상, 오디오 등도 서버가 아닌 브라우저를 통해 직접 다 주고 받을 수 있음
- 이로 인해 서버 부하를 줄이고 네트워크 지연을 최소화 
- 서버 장애가 발생해도 클라이언트간 통신이 계속될 수 있음

> ### P2P (Peer to Peer)
> 중앙 서버를 거치지 않고 클라이언트 컴퓨터끼리 직접 통신하는 방식을 통칭. <br/> 중앙 서버 없이 컴퓨터와 컴퓨터간을 연결해 주며, 프로그램 엔진만 만들면 되기 때문에 <br/>매우 간편하게 파일을 전송할 수 있는 장점이 있음.<br/>

<br/>

## 2. 웹소켓 실행 단계
최초 접속시 HTTP 프로토콜을 이용해 핸드셰이킹함. 

<image src="https://velog.velcdn.com/images/miniso/post/ac94a389-c39d-4622-8301-019a0a0ba661/image.jpg" width="600px">

### 2-1. HTTP 업그레이드 요청 - 웹소켓 연결의 핸드셰이크
클라이언트가 서버에게 웹소켓 연결을 시작하고자 하는 의사를 표시하기 위해 HTTP 업그레이드 요청을 보냄
```
GET /chat
Host: javascript.info
Origin: https://javascript.info
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
Sec-WebSocket-Version: 13
```
- `Origin` <br/>
    서버는 Origin 헤더를 보고 어떤 웹사이트와 소켓 통신할지 결정.
- `Connection: Upgrade`<br/> 
    클라이언트 측에서 프로토콜 바꾸고 싶다는 것을 의미
- `Upgrade: websocket`<br/>
    클라이언트 측에서 요청한 프로토콜은 'websocket'
- `Sec-WebSocket-Key` <br/>
    헤더를 통해 핸드쉐이크 응답을 검증할 키 값을 보냄
- `Sec-WebSocket-Version` <br/>
    웹소켓 프로토콜 버전 명시 

### 2-2. HTTP 업그레이드 응답
```
101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=
```
- 웹소켓 통신 요청을 최초로 받고 이에 동의하면, HTTP 101 (Switching Protocols) 상태 코드 반환. 
- 101 상태코드는 클라이언트와 서버 간에 웹소켓 연결이 확립되었음을 나타냄

- `Sec-WebSocket-Accept`<br/>
특별한 알고리즘을 사용해 만든 Sec-WebSocket-Key. 이 값을 보고 브라우저는 서버가 진짜 웹소켓 프로토콜을 지원하는지 확인
- 핸드셰이크가 끝나면 HTTP 프로토콜이 아닌 웹소켓 프로토콜을 사용해 데이터가 전송되기 시작

### 2-3. 웹소켓 연결 
- HTTP 업그레이드 후 웹소켓 연결로 프로토콜이 전환.
- 이제 양방향으로 데이터를 주고받을 수 있게 되며, 이 데이터는 웹소켓 프레임 형식으로 전송.


<br/>

## 3. 알아두기
> ### ✦ 핸드셰이크
> - 컴퓨터 네트워크에서 두 시스템 사이의 통신을 시작하기 전 서로의 신원을 확인하고 프로토콜을 협상하는 과정.
> - 보안과 데이터 무결성을 확보하며, 통신을 시작하기 위한 초기화 단계 <br/><br/>
웹 소켓에서 핸드셰이크 과정은 클라이언트와 서버간의 웹소켓 연결을 확립하기 위한 필수적인 과정으로<br/>
클라이언트와 서버는 서로의 신원을 확인하고 연결에 대한 의도를 전달하며 데이터 무결성 확보를 위한 키 교환을 수행.<br/> 
웹소켓 핸드셰이크에서는 보통 랜덤한 값을 포함한 키를 생성하고, 서로 이 키를 교환하여 특정 알고리즘을 통해 값의 일치 여부를 확인.<br/> 이를 통해 클라이언트와 서버는 서로의 신원을 확인하고 데이터를 암호화하거나 무결성을 검증

<br/>

> ### ✦ ws와 wss
> 핸드쉐이크가 완료되면 프로토콜이 ws로 변경, 혹은 데이터 보안을 위해 SSL을 적용한 프로토콜인 wss로 변경
> - ws를 사용해 데이터를 전송하면 데이터가 암호화되어있지 않은 채로 전송되기 때문에 데이터가 그대로 노출되는데<br/>
오래된 proxy 서버의 경우 웹소켓을 인식하지 못해 이상한 헤더가 붙었다고 판단하고 연결을 끊음.<br/>
> - wss는 TSL(전송 계층 보안(Transport Layer Security))이라는 보안 계층을 통과해 전달되므로 <br/>송신자 측에서 데이터가 암호화되고, 복호화는 수신자 측에서 이뤄짐.<br/> 따라서 데이터가 담긴 패킷이 암호화된 상태로 proxy 서버를 통과하므로 proxy 서버는 패킷 내부를 볼 수 없게 됨.

<br/>

> ### ✦ socket.io 라이브러리 
> - 연결 끊기면 자동 재접속 기능
> - 웹소켓 접속자마자 자동 id 부여
> - 모든 웹소켓 유저에게 전체 메세지 전송가능
> - 웹소켓방을 생성 가능

<br/>

### 참고자료
- https://tecoble.techcourse.co.kr/post/2020-09-20-websocket/
- https://namu.wiki/w/P2P 
- https://tecoble.techcourse.co.kr/post/2020-09-20-websocket/
- https://ko.javascript.info/websocket
- https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers