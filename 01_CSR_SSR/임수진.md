웹페이지를 렌더링하는 방식에는 크게 SSR(Server Side Rendering)과 CSR(Client Side Rendering)이 있다.
서로 상반되는 관계로 장단점이 서로 엇갈려 있다.
따라서 각각의 특징을 정확하게 알고, 상황에 따라 필요한 방식으로 사용하는 것이 중요하다.

# CSR(Client Side Rendering)
서버가 요청을 받으면 클라이언트에 HTML, JS를 보내주고 클라이언트가 그것을 받아 렌더링하는 방식

### 일반적으로 사용했을 때 대표적인 예시
React, Vue, Angular, Svelte

### 일반적인 CSR의 흐름
- 사용자는 웹사이트로 요청을 보낸다. (보통 브라우저를 통해)
- 서버를 대신해서 CDN(Content Delivery Network)은 정적인 HTML, CSS 파일과 JS로 접근할 수 있는 링크를 사용자(브라우저)에게 전달한다.
- 브라우저는 HTML 파일을 다운받은 다음, JS 파일을 다운받는다. 이 과정이 진행되는 동안 사용자는 빈 화면이나 로딩 화면을 보게 된다.
- 다운 받은JS를 실행하면, AJAX를 통해 API 요청을 만들어 동적 콘텐츠를 가져오고, 이것을 파싱하여 최종 컨텐츠를 렌더링한다. <br>(이 순간부터 웹사이트가 사용자에게 보여지고, 사용자와 상호작용이 가능해진다.)

<img width="559" alt="스크린샷 2023-02-19 오후 9 11 39" src="https://user-images.githubusercontent.com/102905624/219947163-9b462cab-4ed3-4a30-ae51-dba2e1a85982.png">
<br>



# SSR(Server Side Rendering)
서버에서 렌더링 준비를 끝낸 상태로 사용자에게 페이지를 보여주는 방식

### 일반적으로 사용했을 때 대표적인 예시
Next.js, Nuxt.js, PHP

### 일반적인 SSR의 흐름
- 사용자는 웹사이트로 요청을 보낸다. (보통 브라우저를 통해)
- 서버는 자원이 있는지 확인하고 컴파일한다.
- 브라우저는 만들어진(컴파일된) HTML을 다운로드하고 사이트가 사용자에게 보여진다.<br> (하지만 JS를 받아오지 않아 사용자가 클릭해도 아무 반응이 없다.)
- 브라우저는 JS를 다운로드하고 JS를 실행한다.<br> (이때부터 사용자와 상호작용이 가능하다. 클릭에 반응 가능.)
<img width="674" alt="스크린샷 2023-02-19 오후 9 02 00" src="https://user-images.githubusercontent.com/102905624/219946605-017a637c-34b4-4bb3-a844-7a4fe2af3256.png">


------
## CSR와 SSR 비교
### 1. 웹 페이지 로드 속도
- 첫 페이지 로드 시간<br>
CSR의 경우 HTML, CSS 및 필요한 모든 스크립트를 한 번에 불러온다. 반면 **SSR**은 필요한 부분의 HTML과 스크립트만 불러온다. 따라서 일반적으로 SSR이 더 빠르다.

- 나머지 페이지 로드 시간<br>
첫 페이지를 로딩한 후, 사이트의 다른 곳으로 이동한다고 가정해보자.<br>
**CSR**은 이미 첫 페이지 로딩할 때 나머지 부분을 구성하는 코드를 받아왔기 때문에 빠르다.<br>
반면, SSR은 첫 페이지를 로딩한 과정을 정확하게 다시 실행한다. 그래서 CSR보다 더 느리며 화면 깜박임 현상이 발생한다.

### 2. SEO (Search Engine Optimization)
구글, 네이버와 같은 검색엔진들은 서버에 등록된 웹사이트를 하나씩 돌아다니며 웹사이트의 html 문서를 분석해서 우리가 검색할 때 웹사이트를 빠르게 검색할 수 있게 도와준다.
하지만 CSR에서 사용되어지고 있는 html의 body는 대부분 텅텅 비어있기 때문에
검색엔진들이 CSR로 작성된 웹페이지를 분석하는데 어려움이 있다.
구글에서는 조금 개선이 되었지만 여전히 SEO가 좋지 않다.
반면 **SSR**은 서버에서 렌더링 후 각각 페이지를 넘겨받는 것이므로 각각 페이지에 대한 정보를 입력하기 쉬워 SEO가 좋다.

### 3. 서버 부하
SSR이 **CSR**에 비해 더 많은 서버 부하를 발생시킨다. 사용자의 요청이 있을 때마다 필요하 데이터르 매번 서버에 요청 하기 때문이다.

### 4. TTV(Time to view), TTI(Time to interact)
- TTV(Time to view): 웹사이트 화면을 볼 수 있는 시간
- TTI(Time to interact): 웹사이트와 상호작용을 할 수 있는 시간

CSR의 경우, 한꺼번에 파일을 받아와 느린 대신 사용자가 웹사이트를 볼 수 있음과 동시에 클릭하는 등의 상호작용이 가능하지만
(TTV, TTI 동시에 가능)<br>
SSR은 서버에서 HTML 파일을 받아오면 웹사이트를 볼 수 있다. 하지만 아직 동적으로 제어할 수 있는 JS 파일은 받아오지 않았으므로
사용자가 클릭해도 아무 처리를 할 수 없다. 최종적으로 자바스크립트 파일을 서버에서 받아와야만 그때부터 사용자의 클릭을 처리할 수 있는 상호작용이 가능해진다.
그래서 SSR은 사용자가 사이트를 볼 수 있는 시간과, 실제로 인터렉션할 수 있는 시간의 공백기간이 긴편이다.
(TTV 먼저, TTI는 JS 파일을 받아온 후에)


## CSR, SSR 중 무엇을 사용해야 할까
요즘엔 꼭 CSR, SSR 만을 고집해서 사용하기 보다는 SSG(Static Site Generaion)라는 것도 있다.<br>
리액트의 경우 클라이언트 사이드 렌더링에 특화된 라이브러리지만, 개츠비라는 라이브러리와 함께 사용하면
리액트로 만들 웹어플리케이션을 정적으로 웹페이지 생성을 미리 해두어서 서버에 배포해 놓을 수 있다.

그리고 이렇게 만들어진 웹사이트들은 모두 다 정적인 것은 아니다.
추가적으로 데이터를 서버에서 받아오거나 또는 동적으로 처리해야 하는 로직이 있다면
자바스크립트 파일을 함께 가지고 있을 수 있기 때문에 동적인 요소도 충분히 추가할 수가 있다.

그리고 개츠비 다음으로 리액트에서 많이 사용되는 게 Next.js다.
Next.js는 강력한 서버사이드 렌더링을 지원하는 라이브러리였는데 요즘엔 SSG도 지원하고
CSR과 SSR을 잘 섞어서 조금 더 강력하고 유연하게 우리의 목적에 맞게 사용할 수 있도록 지원해주고 있다.

사이트가 정적인지 동적인지, 서버에서 동적으로 데이터를 받아 오는지, 얼마나 자주 얼마나 많은 사용자가 있는지에 따라서 TTV(Time to view)와 TTI(time to interact)를 고려해서
조금 더 유연하게 섞어가면서 개발해나가면 좋겠다.
<br><br>

#### Reference
https://www.solutelabs.com/blog/client-side-vs-server-side-rendering-what-to-choose-when<br>
https://medium.com/walmartglobaltech/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8<br>
https://www.youtube.com/watch?v=iZ9csAfU5Os
